/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ImageCaptions,
  renderMarkdown: () => renderMarkdown
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  captionRegex: ""
};
var CaptionSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Advanced settings").setHeading();
    new import_obsidian.Setting(containerEl).setName("Caption regex").setDesc("For advanced caption parsing, you can add a regex here. The first capturing group will be used as the image caption. This is useful in situations where you might have another plugin or theme adding text to the caption area which you want to strip out. The placeholder example would be used to exclude everything following a pipe character (if one exists).").addText((text) => text.setPlaceholder("^([^|]+)").setValue(this.plugin.settings.captionRegex).onChange(async (value) => {
      this.plugin.settings.captionRegex = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/main.ts
var filenamePlaceholder = "%";
var filenameExtensionPlaceholder = "%.%";
var ImageCaptions = class extends import_obsidian2.Plugin {
  async onload() {
    this.registerMarkdownPostProcessor(
      this.externalImageProcessor()
    );
    await this.loadSettings();
    this.addSettingTab(new CaptionSettingTab(this.app, this));
    this.observer = new MutationObserver((mutations) => {
      mutations.forEach((rec) => {
        if (rec.type === "childList") {
          rec.target.querySelectorAll(".image-embed, .video-embed").forEach(async (imageEmbedContainer) => {
            var _a, _b;
            const img = imageEmbedContainer.querySelector("img, video");
            const width = imageEmbedContainer.getAttribute("width") || "";
            const parsedData = this.parseImageData(imageEmbedContainer);
            if (!img) return;
            const figure = imageEmbedContainer.querySelector("figure");
            const figCaption = imageEmbedContainer.querySelector("figcaption");
            if (figure || ((_a = img.parentElement) == null ? void 0 : _a.nodeName) === "FIGURE") {
              if (figCaption && parsedData.caption) {
                const children = (_b = await renderMarkdown(parsedData.caption, "", this)) != null ? _b : [parsedData.caption];
                figCaption.replaceChildren(...children);
              } else if (!parsedData.caption) {
                imageEmbedContainer.appendChild(img);
                figure == null ? void 0 : figure.remove();
              }
            } else {
              if (parsedData.caption && parsedData.caption !== imageEmbedContainer.getAttribute("src")) {
                await this.insertFigureWithCaption(img, imageEmbedContainer, parsedData, "");
              }
            }
            if (width) {
              img.setAttribute("width", width);
            } else {
              img.removeAttribute("width");
            }
          });
        }
      });
    });
    this.observer.observe(document.body, {
      subtree: true,
      childList: true
    });
  }
  /**
   * Parse image data from alt attribute
   */
  parseImageData(img) {
    let altText = img.getAttribute("alt") || "";
    const src = img.getAttribute("src") || "";
    const edge = altText.replace(/ > /, "#");
    if (altText === src || edge === src) {
      return { caption: "", dataNom: "image", id: this.generateSlug(src) };
    }
    const parts = altText.split("|").map((part) => part.trim());
    const result = {
      dataNom: "image",
      caption: "",
      width: void 0,
      printwidth: void 0,
      col: void 0,
      printcol: void 0,
      class: [],
      poster: void 0,
      imgX: void 0,
      imgY: void 0,
      imgW: void 0,
      id: this.generateSlug(src)
    };
    if (parts.length > 1 && ["imagenote", "image", "imageGrid", "figure", "video"].includes(parts[0])) {
      result.dataNom = parts[0];
      for (let i = 1; i < parts.length; i++) {
        const part = parts[i];
        if (part.includes(":")) {
          const [key, ...valueParts] = part.split(":");
          const value = valueParts.join(":").trim();
          switch (key.toLowerCase()) {
            case "caption":
              result.caption = value;
              break;
            case "width":
              result.width = value;
              break;
            case "printwidth":
              result.printwidth = value;
              break;
            case "col":
              result.col = value;
              break;
            case "printcol":
              result.printcol = value;
              break;
            case "class":
              result.class = value.split(",").map((c) => c.trim());
              break;
            case "poster":
              result.poster = value;
              break;
            case "imgx":
              result.imgX = value;
              break;
            case "imgy":
              result.imgY = value;
              break;
            case "imgw":
              result.imgW = value;
              break;
            case "id":
              result.id = value;
              break;
          }
        }
      }
    } else {
      result.caption = parts[0];
    }
    if (this.settings.captionRegex && result.caption) {
      try {
        const match = result.caption.match(new RegExp(this.settings.captionRegex));
        result.caption = (match == null ? void 0 : match[1]) || "";
      } catch (e) {
      }
    }
    if (result.caption === filenamePlaceholder) {
      const match = src.match(/[^\\/]+(?=\.\w+$)|[^\\/]+$/);
      result.caption = (match == null ? void 0 : match[0]) || "";
    } else if (result.caption === filenameExtensionPlaceholder) {
      const match = src.match(/[^\\/]+$/);
      result.caption = (match == null ? void 0 : match[0]) || "";
    } else if (result.caption === "\\" + filenamePlaceholder) {
      result.caption = filenamePlaceholder;
    }
    result.caption = result.caption.replace(/<<(.*?)>>/g, (_, linktext) => "[[" + linktext + "]]");
    return result;
  }
  /**
   * Generate a slug from image src
   */
  generateSlug(src) {
    const filename = src.split("/").pop() || src;
    const nameWithoutExt = filename.replace(/\.[^.]+$/, "");
    return nameWithoutExt.toLowerCase().replace(/[^a-z0-9]/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
  }
  /**
   * Process an HTMLElement or Element to extract the caption text
   * from the alt attribute.
   *
   * Optionally use the image filename if the filenamePlaceholder is specified.
   *
   * @param img
   */
  getCaptionText(img) {
    const parsedData = this.parseImageData(img);
    return parsedData.caption;
  }
  /**
   * External images can be processed with a Markdown Post Processor, but only in Reading View.
   */
  externalImageProcessor() {
    return (el, ctx) => {
      el.findAll("img:not(.emoji), video").forEach(async (img) => {
        const parsedData = this.parseImageData(img);
        const parent = img.parentElement;
        if (parent && (parent == null ? void 0 : parent.nodeName) !== "FIGURE" && parsedData.caption && parsedData.caption !== img.getAttribute("src")) {
          await this.insertFigureWithCaption(img, parent, parsedData, ctx.sourcePath);
        }
      });
    };
  }
  /**
   * Replace the original <img> element with appropriate structure
   */
  async insertFigureWithCaption(imageEl, outerEl, parsedData, sourcePath) {
    var _a, _b, _c;
    let container;
    if (parsedData.dataNom === "imagenote") {
      container = outerEl.createEl("span");
      container.addClass("imagenote");
      container.setAttribute("id", parsedData.id);
      container.setAttribute("data-src", imageEl.getAttribute("src") || "");
      if (parsedData.class && parsedData.class.length > 0) {
        parsedData.class.forEach((cls) => container.addClass(cls));
      }
      container.appendChild(imageEl);
      if (parsedData.caption) {
        const captionSpan = container.createEl("span", { cls: "caption" });
        const children = (_a = await renderMarkdown(parsedData.caption, sourcePath, this)) != null ? _a : [parsedData.caption];
        captionSpan.replaceChildren(...children);
      }
    } else if (parsedData.dataNom === "video") {
      container = outerEl.createEl("figure");
      container.addClass("videofigure");
      container.setAttribute("data-src", imageEl.getAttribute("src") || "");
      if (parsedData.class && parsedData.class.length > 0) {
        parsedData.class.forEach((cls) => container.addClass(cls));
      }
      const style = [];
      if (parsedData.width) style.push(`--width: ${parsedData.width}px`);
      if (parsedData.printwidth) style.push(`--print-width: ${parsedData.printwidth}px`);
      if (parsedData.col) style.push(`--columns: ${parsedData.col}`);
      if (parsedData.printcol) style.push(`--print-columns: ${parsedData.printcol}`);
      if (parsedData.imgX) style.push(`--img-x: ${parsedData.imgX}px`);
      if (parsedData.imgY) style.push(`--img-y: ${parsedData.imgY}px`);
      if (parsedData.imgW) style.push(`--img-w: ${parsedData.imgW}px`);
      if (style.length > 0) {
        container.setAttribute("style", style.join("; "));
      }
      const videoDiv = container.createEl("div", { cls: "video" });
      if (parsedData.poster) {
        videoDiv.setAttribute("style", `background-image: url(${parsedData.poster})`);
      }
      const src = imageEl.getAttribute("src") || "";
      const videoContent = this.createVideoContent(src);
      if (videoContent) {
        videoDiv.innerHTML = videoContent;
      } else {
        videoDiv.appendChild(imageEl);
      }
      if (parsedData.caption) {
        const children = (_b = await renderMarkdown(parsedData.caption, sourcePath, this)) != null ? _b : [parsedData.caption];
        container.createEl("figcaption", {
          cls: "figcaption"
        }).replaceChildren(...children);
      }
    } else {
      container = outerEl.createEl("figure");
      container.addClass("mediashortcode-figure");
      container.setAttribute("data-nom", parsedData.dataNom);
      container.setAttribute("id", parsedData.id);
      if (parsedData.class && parsedData.class.length > 0) {
        parsedData.class.forEach((cls) => container.addClass(cls));
      }
      const style = [];
      if (parsedData.width) style.push(`--width: ${parsedData.width}px`);
      if (parsedData.printwidth) style.push(`--print-width: ${parsedData.printwidth}px`);
      if (parsedData.col) style.push(`--columns: ${parsedData.col}`);
      if (parsedData.printcol) style.push(`--print-columns: ${parsedData.printcol}`);
      if (parsedData.imgX) style.push(`--img-x: ${parsedData.imgX}px`);
      if (parsedData.imgY) style.push(`--img-y: ${parsedData.imgY}px`);
      if (parsedData.imgW) style.push(`--img-w: ${parsedData.imgW}px`);
      if (style.length > 0) {
        container.setAttribute("style", style.join("; "));
      }
      if (parsedData.poster && imageEl.tagName.toLowerCase() === "video") {
        imageEl.setAttribute("poster", parsedData.poster);
      }
      container.appendChild(imageEl);
      if (parsedData.caption) {
        const children = (_c = await renderMarkdown(parsedData.caption, sourcePath, this)) != null ? _c : [parsedData.caption];
        container.createEl("figcaption", {
          cls: "mediashortcode-caption"
        }).replaceChildren(...children);
      }
    }
  }
  /**
   * Create video content for YouTube/Vimeo URLs
   */
  createVideoContent(url) {
    if (url.includes("yout")) {
      return this.createYouTubeEmbed(url);
    }
    if (url.includes("vimeo")) {
      return this.createVimeoEmbed(url);
    }
    return null;
  }
  createYouTubeEmbed(url) {
    const match = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]+)/);
    if (!match) return null;
    const videoId = match[1];
    const src = `https://www.youtube.com/embed/${videoId}?autoplay=1&rel=0`;
    return `<youtube-embed><iframe scrolling='no' width='640' height='360' allow='autoplay; fullscreen' src='' data-src='${src}'></iframe><button aria-label='Play video'></button></youtube-embed>`;
  }
  createVimeoEmbed(url) {
    const match = url.match(/(?:vimeo\.com\/|player\.vimeo\.com\/video\/)([0-9]+)/);
    if (!match) return null;
    const videoId = match[1];
    const src = `https://player.vimeo.com/video/${videoId}?autoplay=1&rel=0`;
    return `<vimeo-embed><iframe scrolling='no' width='640' height='360' allow='autoplay; fullscreen' src='' data-src='${src}'></iframe><button aria-label='Play video'></button></vimeo-embed>`;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  onunload() {
    this.observer.disconnect();
  }
};
async function renderMarkdown(markdown, sourcePath, component) {
  const el = createDiv();
  await import_obsidian2.MarkdownRenderer.renderMarkdown(markdown, el, sourcePath, component);
  for (const child of el.children) {
    if (child.tagName.toLowerCase() === "p") {
      return child.childNodes;
    }
  }
}
